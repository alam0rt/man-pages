.\" Copyright 2022 Alejandro Colomar <alx@kernel.org>
.\"
.\" SPDX-License-Identifier: Linux-man-pages-copyleft
.\"
.TH strncat 3 (date) "Linux man-pages (unreleased)"
.SH NAME
strncat \- concatenate an unterminated string into a string
.SH LIBRARY
Standard C library
.RI ( libc ", " \-lc )
.SH SYNOPSIS
.nf
.B #include <string.h>
.PP
.BI "char *strncat(char " dest "[restrict strlen(." dest ") + ." n " + 1],"
.BI "              const char " src "[restrict ." n ],
.BI "              size_t " n );
.fi
.SH DESCRIPTION
.IR Note :
This is probably not the function you want to use.
For safe string concatenation, see
.BR strlcat (3bsd).
For copying or concatenating a string into a fixed-length buffer
with zeroing of the rest, see
.BR stpncpy (3).
.PP
.BR strncat ()
appends at most
.I n
characters of
.I src
to the end of
.IR dst .
It always terminates with a null character the string placed in
.IR dest .
.PP
An implementation of
.BR strncat ()
might be:
.PP
.in +4n
.EX
char *
strncat(char *dest, const char *src, size_t n)
{
    char    *cat, *end;
    size_t  len;

    cat = dest + strlen(dest);
    len = strnlen(src, n);
    end = mempcpy(cat, src, len);
    *end = \(aq\e0\(aq;

    return dest;
}
.EE
.in
.SH RETURN VALUE
.BR strncat ()
returns a pointer to the resulting string
.IR dest .
.SH ATTRIBUTES
For an explanation of the terms used in this section, see
.BR attributes (7).
.ad l
.nh
.TS
allbox;
lbx lb lb
l l l.
Interface	Attribute	Value
T{
.BR strncat ()
T}	Thread safety	MT-Safe
.TE
.hy
.ad
.sp 1
.SH STANDARDS
POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD.
.SH NOTES
.SS ustr2stpe()
You may want to write your own function similar to
.BR strncpy (),
with the following improvements:
.IP \(bu 3
Copy, instead of concatenating.
There's no equivalent of
.BR strncat ()
that copies instead of concatenating.
.IP \(bu
Allow chaining the function,
by returning a suitable pointer.
.IP \(bu
Prevent buffer overruns by truncating instead.
.IP \(bu
Report truncation,
by returning a suitable pointer.
.IP \(bu
A name that tells what it does:
Copy from an
.IR u nterminated
.IR str ing
to a
.IR st ring
delimited by a pointer to one
.IR p ast
the
.IR e nd
of the array.
.PP
.in +4n
.EX
/* This code is in the public domain */
char *
ustr2stpe(char *dst, const char *restrict src, size_t n, char past_end[0])
{
    bool       trunc;
    char       *end;
    ptrdiff_t  len;

    if (dst == past_end)
        return past_end;

    trunc = false;
    len = strnlen(src, n);
    if (len > past_end \- dst \- 1) {
        len = past_end \- dst \- 1;
        trunc = true;
    }

    end = mempcpy(dst, src, len);
    *end = \(aq\e0\(aq;

    return trunc ? past_end : end;
}
.EE
.in
.PP
That function is not present in libc,
but it's safer and faster than
.BR strncpy (3).
If defined as an inline function,
there's even a chance that the compiler will collapse it to just a
.BR mempcpy (3).
.SH BUGS
.BR strncat (3)
has a
.I very
misleading name;
it has no relationship with
.BR strncpy (3).
.PP
Since it doesn't know the size of the destination buffer,
this function can easily write past the end of the array,
causing Undefined Behavior.
.SH EXAMPLES
The following two programs are equivalent,
except that the one using
.BR strncat (3)
can't protect from buffer overruns.
One uses
.BR ustr2stpe (),
and the other uses
.BR strncat ().
.SS ustr2stpe()
.in +4n
.\" SRC BEGIN (ustr2stpe.c)
.EX
#define _GNU_SOURCE
#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define nitems(arr)    (sizeof((arr)) / sizeof((arr)[0]))

char *
my_ustr2stpe(char *dst, const char *restrict src, size_t n, char past_end[0])
{
    bool       trunc;
    char       *end;
    ptrdiff_t  len;

    if (dst == past_end)
        return past_end;

    trunc = false;
    len = strnlen(src, n);
    if (len > past_end \- dst \- 1) {
        len = past_end \- dst \- 1;
        trunc = true;
    }

    end = mempcpy(dst, src, len);
    *end = \(aq\e0\(aq;

    return trunc ? past_end : end;
}

int
main(void)
{
    char pre[4] = "pre.";
    char *post = ".post";
    char *src = "some_long_body.post";
    char dest[100];
    char *p, *past_end;

    past_end = dest + nitems(dest);
    p = dest;
    p = my_ustr2stpe(p, pre, nitems(pre), past_end);
    p = my_ustr2stpe(p, src, strlen(src) - strlen(post), past_end);
    p = my_ustr2stpe(p, "", 0, past_end);
    if (p == past_end)
        fprintf(stderr, "truncation\en");

    puts(dest);  // "pre.some_long_body"
    exit(EXIT_SUCCESS);
}
.EE
.\" SRC END
.in
.SS strncat()
.in +4n
.\" SRC BEGIN (strncpy.c)
.EX
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define nitems(arr)  (sizeof((arr)) / sizeof((arr)[0]))

int
main(void)
{
    char pre[4] = "pre.";
    char *post = ".post";
    char *src = "some_long_body.post";
    char dest[100];

    dest[0] = \(aq\e0\(aq;
    strncat(dest, pre, nitems(pre));
    strncat(dest, src, strlen(src) \- strlen(post));
    strncat(dest, "", 0);

    puts(dest);  // "pre.some_long_body"
    exit(EXIT_SUCCESS);
}
.EE
.\" SRC END
.in
.SH SEE ALSO
.BR memccpy (3),
.BR memcpy (3),
.BR mempcpy (3),
.BR strcpy (3),
.BR string (3)
