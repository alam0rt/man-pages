.\" Copyright (c) 2016, IBM Corporation.
.\" Written by Mike Rapoport <rppt@linux.vnet.ibm.com>
.\" and Copyright (C) 2016 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" SPDX-License-Identifier: Linux-man-pages-copyleft
.\"
.\"
.TH ioctl_userfaultfd 2 (date) "Linux man-pages (unreleased)"
.SH NAME
ioctl_userfaultfd \- create a file descriptor for handling page faults in user
space
.SH LIBRARY
Standard C library
.RI ( libc ", " \-lc )
.SH SYNOPSIS
.nf
.BR "#include <linux/userfaultfd.h>" "  /* Definition of " UFFD* " constants */"
.B #include <sys/ioctl.h>
.P
.BI "int ioctl(int " fd ", int " op ", ...);"
.fi
.SH DESCRIPTION
Various
.BR ioctl (2)
operations can be performed on a userfaultfd object (created by a call to
.BR userfaultfd (2))
using calls of the form:
.P
.in +4n
.EX
ioctl(fd, op, argp);
.EE
.in
.P
In the above,
.I fd
is a file descriptor referring to a userfaultfd object,
.I op
is one of the operations listed below, and
.I argp
is a pointer to a data structure that is specific to
.IR op .
.P
The various
.BR ioctl (2)
operations are described below.
The
.BR UFFDIO_API ,
.BR UFFDIO_REGISTER ,
and
.B UFFDIO_UNREGISTER
operations are used to
.I configure
userfaultfd behavior.
These operations allow the caller to choose what features will be enabled and
what kinds of events will be delivered to the application.
The remaining operations are
.I range
operations.
These operations enable the calling application to resolve page-fault
events.
.\"
.TP
.BR UFFDIO_API (2const)
.TQ
.BR UFFDIO_REGISTER (2const)
.TQ
.BR UFFDIO_UNREGISTER (2const)
.TQ
.BR UFFDIO_COPY (2const)
.TQ
.BR UFFDIO_ZEROPAGE (2const)
.TQ
.BR UFFDIO_WAKE (2const)
.TQ
.BR UFFDIO_WRITEPROTECT (2const)
.TQ
.BR UFFDIO_CONTINUE (2const)
.SS UFFDIO_POISON
(Since Linux 6.6.)
Mark an address range as "poisoned".
Future accesses to these addresses will raise a
.B SIGBUS
signal.
Unlike
.B MADV_HWPOISON
this works by installing page table entries,
rather than "really" poisoning the underlying physical pages.
This means it only affects this particular address space.
.P
The
.I argp
argument is a pointer to a
.I uffdio_poison
structure as shown below:
.P
.in +4n
.EX
struct uffdio_poison {
	struct uffdio_range range;
	                /* Range to install poison PTE markers in */
	__u64 mode;     /* Flags controlling the behavior of poison */
	__s64 updated;  /* Number of bytes poisoned, or negated error */
};
.EE
.in
.P
The following value may be bitwise ORed in
.I mode
to change the behavior of the
.B UFFDIO_POISON
operation:
.TP
.B UFFDIO_POISON_MODE_DONTWAKE
Do not wake up the thread that waits for page-fault resolution.
.P
The
.I updated
field is used by the kernel
to return the number of bytes that were actually poisoned,
or an error in the same manner as
.BR UFFDIO_COPY .
If the value returned in the
.I updated
field doesn't match the value that was specified in
.IR range.len ,
the operation fails with the error
.BR EAGAIN .
The
.I updated
field is output-only;
it is not read by the
.B UFFDIO_POISON
operation.
.P
This
.BR ioctl (2)
operation returns 0 on success.
In this case,
the entire area was poisoned.
On error, \-1 is returned and
.I errno
is set to indicate the error.
Possible errors include:
.TP
.B EAGAIN
The number of bytes mapped
(i.e., the value returned in the
.I updated
field)
does not equal the value that was specified in the
.I range.len
field.
.TP
.B EINVAL
Either
.I range.start
or
.I range.len
was not a multiple of the system page size; or
.I range.len
was zero; or the range specified was invalid.
.TP
.B EINVAL
An invalid bit was specified in the
.I mode
field.
.TP
.B EEXIST
One or more pages were already mapped in the given range.
.TP
.B ENOENT
The faulting process has changed its virtual memory layout simultaneously with
an outstanding
.B UFFDIO_POISON
operation.
.TP
.B ENOMEM
Allocating memory for page table entries failed.
.TP
.B ESRCH
The faulting process has exited at the time of a
.B UFFDIO_POISON
operation.
.\"
.SH RETURN VALUE
See descriptions of the individual operations, above.
.SH ERRORS
See descriptions of the individual operations, above.
In addition, the following general errors can occur for all of the
operations described above:
.TP
.B EFAULT
.I argp
does not point to a valid memory address.
.TP
.B EINVAL
(For all operations except
.BR UFFDIO_API .)
The userfaultfd object has not yet been enabled (via the
.B UFFDIO_API
operation).
.SH STANDARDS
Linux.
.SH EXAMPLES
See
.BR userfaultfd (2).
.SH SEE ALSO
.BR ioctl (2),
.BR mmap (2),
.BR userfaultfd (2)
.P
.I Documentation/admin\-guide/mm/userfaultfd.rst
in the Linux kernel source tree
