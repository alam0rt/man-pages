'\" t
.\" Copyright 2002, Walter Harms <walter.harms@informatik.uni-oldenburg.de>
.\" Copyright 2002, Andries Brouwer <aeb@cwi.nl>
.\" Copyright 2024, Alejandro Colomar <alx@kernel.org>
.\"
.\" SPDX-License-Identifier: GPL-1.0-or-later
.\"
.TH ioctl_tty 2 (date) "Linux man-pages (unreleased)"
.SH NAME
ioctl_tty \- ioctls for terminals and serial lines
.SH LIBRARY
Standard C library
.RI ( libc ", " \-lc )
.SH SYNOPSIS
.nf
.BR "#include <asm/termbits.h>" "  /* Definition of constants */"
.B #include <sys/ioctl.h>
.P
.BI "int ioctl(int " fd ", int " op ", ...);"
.P
.B #include <linux/serial.h>
.P
.B struct serial_icounter_struct;
.fi
.SH DESCRIPTION
The
.BR ioctl (2)
call for terminals and serial ports accepts many possible operation arguments.
Most require a third argument, of varying type, here called
.I argp
or
.IR arg .
.P
Use of
.BR ioctl ()
makes for nonportable programs.
Use the POSIX interface described in
.BR termios (3)
whenever possible.
.SS Get and set terminal attributes
.TP
.B TCGETS
.TQ
.B TCSETS
.TQ
.B TCSETSW
.TQ
.B TCSETSF
.TP
.B TCGETS
.TQ
.B TCSETS
.TQ
.B TCSETSW
.TQ
.B TCSETSF
.TP
.B TCGETS
.TQ
.B TCSETS
.TQ
.B TCSETSW
.TQ
.B TCSETSF
.SS Locking the termios structure
.TP
.B TIOCGLCKTRMIOS
.TQ
.B TIOCSLCKTRMIOS
.SS Get and set window size
.TP
.B TIOCGWINSZ
.TQ
.B TIOCSWINSZ
.SS Sending a break
.TP
.B TCSBRK
.TQ
.B TCSBRKP
.TQ
.B TIOCSBRK
.TQ
.B TIOCCBRK
.SS Software flow control
.TP
.B TCXONC
.SS Buffer count and flushing
.TP
.B FIONREAD
.TQ
.B TIOCINQ
.TQ
.B TIOCOUTQ
.TQ
.B TCFLSH
.TQ
.B TIOCSERGETLSR
.SS Faking input
.TP
.B TIOCSTI
.SS Redirecting console output
.TP
.B TIOCCONS
.SS Controlling terminal
.TP
.B TIOCSCTTY
Argument:
.BI "int " arg
.IP
Make the given terminal the controlling terminal of the calling process.
The calling process must be a session leader and not have a
controlling terminal already.
For this case,
.I arg
should be specified as zero.
.IP
If this terminal is already the controlling terminal
of a different session group, then the ioctl fails with
.BR EPERM ,
unless the caller has the
.B CAP_SYS_ADMIN
capability and
.I arg
equals 1, in which case the terminal is stolen, and all processes that had
it as controlling terminal lose it.
.TP
.B TIOCNOTTY
Argument:
.B void
.IP
If the given terminal was the controlling terminal of the calling process,
give up this controlling terminal.
If the process was session leader,
then send
.B SIGHUP
and
.B SIGCONT
to the foreground process group
and all processes in the current session lose their controlling terminal.
.SS Process group and session ID
.TP
.B TIOCGPGRP
Argument:
.BI "pid_t\~*" argp
.IP
When successful, equivalent to
.IR "*argp = tcgetpgrp(fd)" .
.IP
Get the process group ID of the foreground process group on this terminal.
.TP
.B TIOCSPGRP
Argument:
.BI "const pid_t\~*" argp
.IP
Equivalent to
.IR "tcsetpgrp(fd, *argp)" .
.IP
Set the foreground process group ID of this terminal.
.TP
.B TIOCGSID
Argument:
.BI "pid_t\~*" argp
.IP
When successful, equivalent to
.IR "*argp = tcgetsid(fd)" .
.IP
Get the session ID of the given terminal.
This fails with the error
.B ENOTTY
if the terminal is not a master pseudoterminal
and not our controlling terminal.
Strange.
.SS Exclusive mode
.TP
.B TIOCEXCL
Argument:
.B void
.IP
Put the terminal into exclusive mode.
No further
.BR open (2)
operations on the terminal are permitted.
(They fail with
.BR EBUSY ,
except for a process with the
.B CAP_SYS_ADMIN
capability.)
.TP
.B TIOCGEXCL
Argument:
.BI "int\~*" argp
.IP
(since Linux 3.8)
If the terminal is currently in exclusive mode,
place a nonzero value in the location pointed to by
.IR argp ;
otherwise, place zero in
.IR *argp .
.TP
.B TIOCNXCL
Argument:
.B void
.IP
Disable exclusive mode.
.SS Line discipline
.TP
.B TIOCGETD
Argument:
.BI "int\~*" argp
.IP
Get the line discipline of the terminal.
.TP
.B TIOCSETD
Argument:
.BI "const int\~*" argp
.IP
Set the line discipline of the terminal.
.SS Pseudoterminal ioctls
.TP
.B TIOCPKT
Argument:
.BI "const int\~*" argp
.IP
Enable (when
.RI * argp
is nonzero) or disable packet mode.
Can be applied to the master side of a pseudoterminal only (and will return
.B ENOTTY
otherwise).
In packet mode, each subsequent
.BR read (2)
will return a packet that either contains a single nonzero control byte,
or has a single byte containing zero (\[aq]\e0\[aq]) followed by data
written on the slave side of the pseudoterminal.
If the first byte is not
.B TIOCPKT_DATA
(0), it is an OR of one
or more of the following bits:
.IP
.ad l
.TS
lb l.
TIOCPKT_FLUSHREAD	T{
The read queue for the terminal is flushed.
T}
TIOCPKT_FLUSHWRITE	T{
The write queue for the terminal is flushed.
T}
TIOCPKT_STOP	T{
Output to the terminal is stopped.
T}
TIOCPKT_START	T{
Output to the terminal is restarted.
T}
TIOCPKT_DOSTOP	T{
The start and stop characters are \fB\[ha]S\fP/\fB\[ha]Q\fP.
T}
TIOCPKT_NOSTOP	T{
The start and stop characters are not \fB\[ha]S\fP/\fB\[ha]Q\fP.
T}
.TE
.ad
.IP
While packet mode is in use, the presence
of control status information to be read
from the master side may be detected by a
.BR select (2)
for exceptional conditions or a
.BR poll (2)
for the
.B POLLPRI
event.
.IP
This mode is used by
.BR rlogin (1)
and
.BR rlogind (8)
to implement a remote-echoed,
locally \fB\[ha]S\fP/\fB\[ha]Q\fP flow-controlled remote login.
.TP
.B TIOCGPKT
Argument:
.BI "const int\~*" argp
.IP
(since Linux 3.8)
Return the current packet mode setting in the integer pointed to by
.IR argp .
.TP
.B TIOCSPTLCK
Argument:
.BI "int\~*" argp
.IP
Set (if
.I *argp
is nonzero) or remove (if
.I *argp
is zero) the lock on the pseudoterminal slave device.
(See also
.BR unlockpt (3).)
.TP
.B TIOCGPTLCK
Argument:
.BI "int\~*" argp
.IP
(since Linux 3.8)
Place the current lock state of the pseudoterminal slave device
in the location pointed to by
.IR argp .
.TP
.B TIOCGPTPEER
Argument:
.BI "int " flags
.IP
.\" commit 54ebbfb1603415d9953c150535850d30609ef077
(since Linux 4.13)
Given a file descriptor in
.I fd
that refers to a pseudoterminal master,
open (with the given
.BR open (2)-style
.IR flags )
and return a new file descriptor that refers to the peer
pseudoterminal slave device.
This operation can be performed
regardless of whether the pathname of the slave device
is accessible through the calling process's mount namespace.
.IP
Security-conscious programs interacting with namespaces may wish to use this
operation rather than
.BR open (2)
with the pathname returned by
.BR ptsname (3),
and similar library functions that have insecure APIs.
(For example, confusion can occur in some cases using
.BR ptsname (3)
with a pathname where a devpts filesystem
has been mounted in a different mount namespace.)
.P
The BSD ioctls
.BR TIOCSTOP ,
.BR TIOCSTART ,
.BR TIOCUCNTL ,
and
.B TIOCREMOTE
have not been implemented under Linux.
.SS Modem control
.TP
.B TIOCMGET
Argument:
.BI "int\~*" argp
.IP
Get the status of modem bits.
.TP
.B TIOCMSET
Argument:
.BI "const int\~*" argp
.IP
Set the status of modem bits.
.TP
.B TIOCMBIC
Argument:
.BI "const int\~*" argp
.IP
Clear the indicated modem bits.
.TP
.B TIOCMBIS
Argument:
.BI "const int\~*" argp
.IP
Set the indicated modem bits.
.P
The following bits are used by the above ioctls:
.P
.TS
lb l.
TIOCM_LE	DSR (data set ready/line enable)
TIOCM_DTR	DTR (data terminal ready)
TIOCM_RTS	RTS (request to send)
TIOCM_ST	Secondary TXD (transmit)
TIOCM_SR	Secondary RXD (receive)
TIOCM_CTS	CTS (clear to send)
TIOCM_CAR	DCD (data carrier detect)
TIOCM_CD	see TIOCM_CAR
TIOCM_RNG	RNG (ring)
TIOCM_RI	see TIOCM_RNG
TIOCM_DSR	DSR (data set ready)
.TE
.TP
.B TIOCMIWAIT
Argument:
.BI "int " arg
.IP
Wait for any of the 4 modem bits (DCD, RI, DSR, CTS) to change.
The bits of interest are specified as a bit mask in
.IR arg ,
by ORing together any of the bit values,
.BR TIOCM_RNG ,
.BR TIOCM_DSR ,
.BR TIOCM_CD ,
and
.BR TIOCM_CTS .
The caller should use
.B TIOCGICOUNT
to see which bit has changed.
.TP
.B TIOCGICOUNT
Argument:
.BI "struct serial_icounter_struct\~*" argp
.IP
Get counts of input serial line interrupts (DCD, RI, DSR, CTS).
The counts are written to the
.I serial_icounter_struct
structure pointed to by
.IR argp .
.IP
Note: both 1->0 and 0->1 transitions are counted, except for
RI, where only 0->1 transitions are counted.
.SS Marking a line as local
.TP
.B TIOCGSOFTCAR
Argument:
.BI "int\~*" argp
.IP
("Get software carrier flag")
Get the status of the CLOCAL flag in the c_cflag field of the
.I termios
structure.
.TP
.B TIOCSSOFTCAR
Argument:
.BI "const int\~*" argp
.IP
("Set software carrier flag")
Set the CLOCAL flag in the
.I termios
structure when
.RI * argp
is nonzero, and clear it otherwise.
.P
If the
.B CLOCAL
flag for a line is off, the hardware carrier detect (DCD)
signal is significant, and an
.BR open (2)
of the corresponding terminal will block until DCD is asserted,
unless the
.B O_NONBLOCK
flag is given.
If
.B CLOCAL
is set, the line behaves as if DCD is always asserted.
The software carrier flag is usually turned on for local devices,
and is off for lines with modems.
.SS Linux-specific
For the
.B TIOCLINUX
ioctl, see
.BR ioctl_console (2).
.SS Kernel debugging
.B "#include <linux/tty.h>"
.TP
.B TIOCTTYGSTRUCT
Argument:
.BI "struct tty_struct\~*" argp
.IP
Get the
.I tty_struct
corresponding to
.IR fd .
This operation was removed in Linux 2.5.67.
.\"     commit b3506a09d15dc5aee6d4bb88d759b157016e1864
.\"     Author: Andries E. Brouwer <andries.brouwer@cwi.nl>
.\"     Date:   Tue Apr 1 04:42:46 2003 -0800
.\"
.\"     [PATCH] kill TIOCTTYGSTRUCT
.\"
.\"     Only used for (dubious) debugging purposes, and exposes
.\"     internal kernel state.
.\"
.\" .SS Serial info
.\" .BR "#include <linux/serial.h>"
.\" .P
.\" .TP
.\" .BI "TIOCGSERIAL	struct serial_struct *" argp
.\" Get serial info.
.\" .TP
.\" .BI "TIOCSSERIAL	const struct serial_struct *" argp
.\" Set serial info.
.SH RETURN VALUE
On success,
0 is returned.
On error,
\-1 is returned, and
.I errno
is set to indicate the error.
.SH ERRORS
.TP
.B EPERM
Insufficient permission.
.SH EXAMPLES
Check the condition of DTR on the serial port.
.P
.\" SRC BEGIN (tiocmget.c)
.EX
#include <fcntl.h>
#include <stdio.h>
#include <sys/ioctl.h>
#include <unistd.h>
\&
int
main(void)
{
    int fd, serial;
\&
    fd = open("/dev/ttyS0", O_RDONLY);
    ioctl(fd, TIOCMGET, &serial);
    if (serial & TIOCM_DTR)
        puts("TIOCM_DTR is set");
    else
        puts("TIOCM_DTR is not set");
    close(fd);
}
.EE
.\" SRC END
.SH SEE ALSO
.BR ioctl (2),
.BR TCGETS (2const),
.BR TCSETS (2const),
.BR TCSETSW (2const),
.BR TCSETSF (2const),
.BR TCGETS (2const),
.BR TCSETS (2const),
.BR TCSETSW (2const),
.BR TCSETSF (2const),
.BR TCGETS (2const),
.BR TCSETS (2const),
.BR TCSETSW (2const),
.BR TCSETSF (2const),
.BR TIOCGLCKTRMIOS (2const),
.BR TIOCSLCKTRMIOS (2const),
.BR TIOCGWINSZ (2const),
.BR TIOCSWINSZ (2const),
.BR TCSBRK (2const),
.BR TCSBRKP (2const),
.BR TIOCSBRK (2const),
.BR TIOCCBRK (2const),
.BR TCXONC (2const),
.BR FIONREAD (2const),
.BR TIOCINQ (2const),
.BR TIOCOUTQ (2const),
.BR TCFLSH (2const),
.BR TIOCSERGETLSR (2const),
.BR TIOCSTI (2const),
.BR TIOCCONS (2const),
.BR ldattach (8),
.BR ioctl_console (2),
.BR termios (3),
.BR pty (7)
.\"
.\" FIONBIO			const int *
.\" FIONCLEX			void
.\" FIOCLEX			void
.\" FIOASYNC			const int *
.\" from serial.c:
.\" TIOCSERCONFIG		void
.\" TIOCSERGWILD		int *
.\" TIOCSERSWILD		const int *
.\" TIOCSERGSTRUCT		struct async_struct *
.\" TIOCSERGETMULTI		struct serial_multiport_struct *
.\" TIOCSERSETMULTI		const struct serial_multiport_struct *
.\" TIOCGSERIAL, TIOCSSERIAL (see above)
