.\" Copyright 2016, Michael Kerrisk <mtk.manpages@gmail.com>
.\" Copyright 2016, Eugene Syromyatnikov <evgsyr@gmail.com>
.\" A very few fragments remain from an earlier version of this page
.\" written by David Howells (dhowells@redhat.com)
.\" Copyright 2024, Alejandro Colomar <alx@kernel.org>
.\"
.\" SPDX-License-Identifier: Linux-man-pages-copyleft
.\"
.TH keyctl 2 (date) "Linux man-pages (unreleased)"
.SH NAME
keyctl \- manipulate the kernel's key management facility
.SH LIBRARY
Standard C library
.RI ( libc ,\~ \-lc )
.SH SYNOPSIS
.nf
.BR "#include <linux/keyctl.h>" "  /* Definition of " KEY* " constants */"
.BR "#include <sys/syscall.h>" "   /* Definition of " SYS_* " constants */"
.B #include <unistd.h>
.P
.BI "long syscall(SYS_keyctl, int " operation ", unsigned long " arg2 ,
.BI "             unsigned long " arg3 ", unsigned long " arg4 ,
.BI "             unsigned long " arg5 );
.fi
.SH DESCRIPTION
.BR keyctl ()
allows user-space programs to perform key manipulation.
.P
The operation performed by
.BR keyctl ()
is determined by the value of the
.I operation
argument.
Each of these operations is wrapped by the
.I libkeyutils
library (provided by the
.I keyutils
package) into individual functions (noted below)
to permit the compiler to check types.
.P
The permitted values for
.I operation
are:
.TP
.BR KEYCTL_GET_KEYRING_ID (2const)
.TQ
.BR KEYCTL_JOIN_SESSION_KEYRING (2const)
.TQ
.BR KEYCTL_UPDATE (2const)
.TQ
.BR KEYCTL_REVOKE (2const)
.TQ
.BR KEYCTL_CHOWN (2const)
.TQ
.BR KEYCTL_SETPERM (2const)
.TQ
.BR KEYCTL_DESCRIBE (2const)
.TQ
.BR KEYCTL_CLEAR (2const)
.TQ
.BR KEYCTL_LINK (2const)
.TQ
.BR KEYCTL_UNLINK (2const)
.TQ
.BR KEYCTL_SEARCH (2const)
.TQ
.BR KEYCTL_READ (2const)
.TP
.BR KEYCTL_INSTANTIATE " (since Linux 2.6.10)"
(Positively) instantiate an uninstantiated key with a specified payload.
.IP
The ID of the key to be instantiated is provided in
.I arg2
(cast to
.IR key_serial_t ).
.IP
The key payload is specified in the buffer pointed to by
.I arg3
(cast to
.IR "void\ *");
the size of that buffer is specified in
.I arg4
(cast to
.IR size_t ).
.IP
The payload may be a null pointer and the buffer size may be 0
if this is supported by the key type (e.g., it is a keyring).
.IP
The operation may be fail if the payload data is in the wrong format
or is otherwise invalid.
.IP
If
.I arg5
(cast to
.IR key_serial_t )
is nonzero, then, subject to the same constraints and rules as
.BR KEYCTL_LINK (2const),
the instantiated key is linked into the keyring whose ID specified in
.IR arg5 .
.IP
The caller must have the appropriate authorization key,
and once the uninstantiated key has been instantiated,
the authorization key is revoked.
In other words, this operation is available only from a
.BR request\-key (8)-style
program.
See
.BR request_key (2)
for an explanation of uninstantiated keys and key instantiation.
.IP
This operation is exposed by
.I libkeyutils
via the function
.BR keyctl_instantiate (3).
.TP
.BR KEYCTL_NEGATE " (since Linux 2.6.10)"
Negatively instantiate an uninstantiated key.
.IP
This operation is equivalent to the call:
.IP
.in +4n
.EX
keyctl(KEYCTL_REJECT, arg2, arg3, ENOKEY, arg4);
.EE
.in
.IP
The
.I arg5
argument is ignored.
.IP
This operation is exposed by
.I libkeyutils
via the function
.BR keyctl_negate (3).
.TP
.BR KEYCTL_SET_REQKEY_KEYRING " (since Linux 2.6.13)"
Set the default keyring to which implicitly requested keys
will be linked for this thread, and return the previous setting.
Implicit key requests are those made by internal kernel components,
.\" I.e., calls to the kernel's internal request_key() interface,
.\" which is distinct from the request_key(2) system call (which
.\" ultimately employs the kernel-internal interface).
such as can occur when, for example, opening files
on an AFS or NFS filesystem.
Setting the default keyring also has an effect when requesting
a key from user space; see
.BR request_key (2)
for details.
.IP
The
.I arg2
argument (cast to
.IR int )
should contain one of the following values,
to specify the new default keyring:
.RS
.TP
.B KEY_REQKEY_DEFL_NO_CHANGE
Don't change the default keyring.
This can be used to discover the current default keyring
(without changing it).
.TP
.B KEY_REQKEY_DEFL_DEFAULT
This selects the default behaviour,
which is to use the thread-specific keyring if there is one,
otherwise the process-specific keyring if there is one,
otherwise the session keyring if there is one,
otherwise the UID-specific session keyring,
otherwise the user-specific keyring.
.TP
.B KEY_REQKEY_DEFL_THREAD_KEYRING
Use the thread-specific keyring
.RB ( thread\-keyring (7))
as the new default keyring.
.TP
.B KEY_REQKEY_DEFL_PROCESS_KEYRING
Use the process-specific keyring
.RB ( process\-keyring (7))
as the new default keyring.
.TP
.B KEY_REQKEY_DEFL_SESSION_KEYRING
Use the session-specific keyring
.RB ( session\-keyring (7))
as the new default keyring.
.TP
.B KEY_REQKEY_DEFL_USER_KEYRING
Use the UID-specific keyring
.RB ( user\-keyring (7))
as the new default keyring.
.TP
.B KEY_REQKEY_DEFL_USER_SESSION_KEYRING
Use the UID-specific session keyring
.RB ( user\-session\-keyring (7))
as the new default keyring.
.TP
.BR KEY_REQKEY_DEFL_REQUESTOR_KEYRING " (since Linux 2.6.29)"
.\" 8bbf4976b59fc9fc2861e79cab7beb3f6d647640
Use the requestor keyring.
.\" FIXME The preceding explanation needs to be expanded.
.\" Is the following correct:
.\"
.\"	The requestor keyring is the dest_keyring that
.\"	was supplied to a call to request_key(2)?
.\"
.\" David Howells said: to be checked
.RE
.IP
All other values are invalid.
.\" (including the still-unsupported KEY_REQKEY_DEFL_GROUP_KEYRING)
.IP
The arguments
.IR arg3 ,
.IR arg4 ,
and
.I arg5
are ignored.
.IP
The setting controlled by this operation is inherited by the child of
.BR fork (2)
and preserved across
.BR  execve (2).
.IP
This operation is exposed by
.I libkeyutils
via the function
.BR keyctl_set_reqkey_keyring (3).
.TP
.BR KEYCTL_SET_TIMEOUT " (since Linux 2.6.16)"
Set a timeout on a key.
.IP
The ID of the key is specified in
.I arg2
(cast to
.IR key_serial_t ).
The timeout value, in seconds from the current time,
is specified in
.I arg3
(cast to
.IR "unsigned int" ).
The timeout is measured against the realtime clock.
.IP
Specifying the timeout value as 0 clears any existing timeout on the key.
.IP
The
.I /proc/keys
file displays the remaining time until each key will expire.
(This is the only method of discovering the timeout on a key.)
.IP
The caller must either have the
.I setattr
permission on the key
or hold an instantiation authorization token for the key (see
.BR request_key (2)).
.IP
The key and any links to the key will be
automatically garbage collected after the timeout expires.
Subsequent attempts to access the key will then fail with the error
.BR EKEYEXPIRED .
.IP
This operation cannot be used to set timeouts on revoked, expired,
or negatively instantiated keys.
.IP
The arguments
.I arg4
and
.I arg5
are ignored.
.IP
This operation is exposed by
.I libkeyutils
via the function
.BR keyctl_set_timeout (3).
.TP
.BR KEYCTL_ASSUME_AUTHORITY " (since Linux 2.6.16)"
Assume (or divest) the authority for the calling thread
to instantiate a key.
.IP
The
.I arg2
argument (cast to
.IR key_serial_t )
specifies either a nonzero key ID to assume authority,
or the value 0 to divest authority.
.IP
If
.I arg2
is nonzero, then it specifies the ID of an uninstantiated key for which
authority is to be assumed.
That key can then be instantiated using one of
.BR KEYCTL_INSTANTIATE ,
.BR KEYCTL_INSTANTIATE_IOV ,
.BR KEYCTL_REJECT ,
or
.BR KEYCTL_NEGATE .
Once the key has been instantiated,
the thread is automatically divested of authority to instantiate the key.
.IP
Authority over a key can be assumed only if the calling thread has present
in its keyrings the authorization key that is
associated with the specified key.
(In other words, the
.B KEYCTL_ASSUME_AUTHORITY
operation is available only from a
.BR request\-key (8)-style
program; see
.BR request_key (2)
for an explanation of how this operation is used.)
The caller must have
.I search
permission on the authorization key.
.IP
If the specified key has a matching authorization key,
then the ID of that key is returned.
The authorization key can be read
.RB ( KEYCTL_READ (2const))
to obtain the callout information passed to
.BR request_key (2).
.IP
If the ID given in
.I arg2
is 0, then the currently assumed authority is cleared (divested),
and the value 0 is returned.
.IP
The
.B KEYCTL_ASSUME_AUTHORITY
mechanism allows a program such as
.BR request\-key (8)
to assume the necessary authority to instantiate a new uninstantiated key
that was created as a consequence of a call to
.BR request_key (2).
For further information, see
.BR request_key (2)
and the kernel source file
.IR Documentation/security/keys\-request\-key.txt .
.IP
The arguments
.IR arg3 ,
.IR arg4 ,
and
.I arg5
are ignored.
.IP
This operation is exposed by
.I libkeyutils
via the function
.BR keyctl_assume_authority (3).
.TP
.BR KEYCTL_GET_SECURITY " (since Linux 2.6.26)"
.\" commit 70a5bb72b55e82fbfbf1e22cae6975fac58a1e2d
Get the LSM (Linux Security Module) security label of the specified key.
.IP
The ID of the key whose security label is to be fetched is specified in
.I arg2
(cast to
.IR key_serial_t ).
The security label (terminated by a null byte)
will be placed in the buffer pointed to by
.I arg3
argument (cast to
.IR "char\ *" );
the size of the buffer must be provided in
.I arg4
(cast to
.IR size_t ).
.IP
If
.I arg3
is specified as NULL or the buffer size specified in
.I arg4
is too small, the full size of the security label string
(including the terminating null byte)
is returned as the function result,
and nothing is copied to the buffer.
.IP
The caller must have
.I view
permission on the specified key.
.IP
The returned security label string will be rendered in a form appropriate
to the LSM in force.
For example, with SELinux, it may look like:
.IP
.in +4n
.EX
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
.EE
.in
.IP
If no LSM is currently in force,
then an empty string is placed in the buffer.
.IP
The
.I arg5
argument is ignored.
.IP
This operation is exposed by
.I libkeyutils
via the functions
.BR keyctl_get_security (3)
and
.BR keyctl_get_security_alloc (3).
.TP
.BR KEYCTL_SESSION_TO_PARENT " (since Linux 2.6.32)"
.\" commit ee18d64c1f632043a02e6f5ba5e045bb26a5465f
Replace the session keyring to which the
.I parent
of the calling process
subscribes with the session keyring of the calling process.
.\" What is the use case for KEYCTL_SESSION_TO_PARENT?
.\" David Howells: the Process Authentication Groups people requested this,
.\" but then didn't use it; maybe there are no users.
.IP
The keyring will be replaced in the parent process at the point
where the parent next transitions from kernel space to user space.
.IP
The keyring must exist and must grant the caller
.I link
permission.
The parent process must be single-threaded and have
the same effective ownership as this process
and must not be set-user-ID or set-group-ID.
The UID of the parent process's existing session keyring (f it has one),
as well as the UID of the caller's session keyring
much match the caller's effective UID.
.IP
The fact that it is the parent process that is affected by this operation
allows a program such as the shell to start a child process that
uses this operation to change the shell's session keyring.
(This is what the
.BR keyctl (1)
.B new_session
command does.)
.IP
The arguments
.IR arg2 ,
.IR arg3 ,
.IR arg4 ,
and
.I arg5
are ignored.
.IP
This operation is exposed by
.I libkeyutils
via the function
.BR keyctl_session_to_parent (3).
.TP
.BR KEYCTL_REJECT " (since Linux 2.6.39)"
.\" commit fdd1b94581782a2ddf9124414e5b7a5f48ce2f9c
Mark a key as negatively instantiated and set an expiration timer
on the key.
This operation provides a superset of the functionality of the earlier
.B KEYCTL_NEGATE
operation.
.IP
The ID of the key that is to be negatively instantiated is specified in
.I arg2
(cast to
.IR key_serial_t ).
The
.I arg3
(cast to
.IR "unsigned int" )
argument specifies the lifetime of the key, in seconds.
The
.I arg4
argument (cast to
.IR "unsigned int" )
specifies the error to be returned when a search hits this key;
typically, this is one of
.BR EKEYREJECTED ,
.BR EKEYREVOKED ,
or
.BR EKEYEXPIRED .
.IP
If
.I arg5
(cast to
.IR key_serial_t )
is nonzero, then, subject to the same constraints and rules as
.BR KEYCTL_LINK (2const),
the negatively instantiated key is linked into the keyring
whose ID is specified in
.IR arg5 .
.IP
The caller must have the appropriate authorization key.
In other words, this operation is available only from a
.BR request\-key (8)-style
program.
See
.BR request_key (2).
.IP
The caller must have the appropriate authorization key,
and once the uninstantiated key has been instantiated,
the authorization key is revoked.
In other words, this operation is available only from a
.BR request\-key (8)-style
program.
See
.BR request_key (2)
for an explanation of uninstantiated keys and key instantiation.
.IP
This operation is exposed by
.I libkeyutils
via the function
.BR keyctl_reject (3).
.TP
.BR KEYCTL_INSTANTIATE_IOV " (since Linux 2.6.39)"
.\" commit ee009e4a0d4555ed522a631bae9896399674f063
Instantiate an uninstantiated key with a payload specified
via a vector of buffers.
.IP
This operation is the same as
.BR KEYCTL_INSTANTIATE ,
but the payload data is specified as an array of
.I iovec
structures (see
.BR iovec (3type)).
.IP
The pointer to the payload vector is specified in
.I arg3
(cast as
.IR "const struct iovec\~*" ).
The number of items in the vector is specified in
.I arg4
(cast as
.IR "unsigned int" ).
.IP
The
.I arg2
(key ID)
and
.I arg5
(keyring ID)
are interpreted as for
.BR KEYCTL_INSTANTIATE .
.IP
This operation is exposed by
.I libkeyutils
via the function
.BR keyctl_instantiate_iov (3).
.TP
.BR KEYCTL_INVALIDATE " (since Linux 3.5)"
.\" commit fd75815f727f157a05f4c96b5294a4617c0557da
Mark a key as invalid.
.IP
The ID of the key to be invalidated is specified in
.I arg2
(cast to
.IR key_serial_t ).
.IP
To invalidate a key,
the caller must have
.I search
permission on the key.
.\" CAP_SYS_ADMIN is permitted to invalidate certain special keys
.IP
This operation marks the key as invalid
and schedules immediate garbage collection.
The garbage collector removes the invalidated key from all keyrings and
deletes the key when its reference count reaches zero.
After this operation,
the key will be ignored by all searches,
even if it is not yet deleted.
.IP
Keys that are marked invalid become invisible to normal key operations
immediately, though they are still visible in
.I /proc/keys
(marked with an 'i' flag)
until they are actually removed.
.IP
The arguments
.IR arg3 ,
.IR arg4 ,
and
.I arg5
are ignored.
.IP
This operation is exposed by
.I libkeyutils
via the function
.BR keyctl_invalidate (3).
.TP
.BR KEYCTL_GET_PERSISTENT " (since Linux 3.13)"
.\" commit f36f8c75ae2e7d4da34f4c908cebdb4aa42c977e
Get the persistent keyring
.RB ( persistent\-keyring (7))
for a specified user and link it to a specified keyring.
.IP
The user ID is specified in
.I arg2
(cast to
.IR uid_t ).
If the value \-1 is specified, the caller's real user ID is used.
The ID of the destination keyring is specified in
.I arg3
(cast to
.IR key_serial_t ).
.IP
The caller must have the
.B CAP_SETUID
capability in its user namespace in order to fetch the persistent keyring
for a user ID that does not match either the real or effective user ID
of the caller.
.IP
If the call is successful,
a link to the persistent keyring is added to the keyring
whose ID was specified in
.IR arg3 .
.IP
The caller must have
.I write
permission on the keyring.
.IP
The persistent keyring will be created by the kernel
if it does not yet exist.
.IP
Each time the
.B KEYCTL_GET_PERSISTENT
operation is performed, the persistent keyring will
have its expiration timeout reset to the value in:
.IP
.in +4n
.EX
/proc/sys/kernel/keys/persistent_keyring_expiry
.EE
.in
.IP
Should the timeout be reached,
the persistent keyring will be removed and
everything it pins can then be garbage collected.
.IP
Persistent keyrings were added in Linux 3.13.
.IP
The arguments
.I arg4
and
.I arg5
are ignored.
.IP
This operation is exposed by
.I libkeyutils
via the function
.BR keyctl_get_persistent (3).
.TP
.BR KEYCTL_DH_COMPUTE " (since Linux 4.7)"
.\" commit ddbb41148724367394d0880c516bfaeed127b52e
Compute a Diffie-Hellman shared secret or public key,
optionally applying key derivation function (KDF) to the result.
.IP
The
.I arg2
argument is a pointer to a set of parameters containing
serial numbers for three
.I \[dq]user\[dq]
keys used in the Diffie-Hellman calculation,
packaged in a structure of the following form:
.IP
.in +4n
.EX
struct keyctl_dh_params {
    int32_t private; /* The local private key */
    int32_t prime; /* The prime, known to both parties */
    int32_t base;  /* The base integer: either a shared
                      generator or the remote public key */
};
.EE
.in
.IP
Each of the three keys specified in this structure must grant the caller
.I read
permission.
The payloads of these keys are used to calculate the Diffie-Hellman
result as:
.IP
.in +4n
.EX
base \[ha] private mod prime
.EE
.in
.IP
If the base is the shared generator, the result is the local public key.
If the base is the remote public key, the result is the shared secret.
.IP
The
.I arg3
argument (cast to
.IR char\~* )
points to a buffer where the result of the calculation is placed.
The size of that buffer is specified in
.I arg4
(cast to
.IR size_t ).
.IP
The buffer must be large enough to accommodate the output data,
otherwise an error is returned.
If
.I arg4
is specified zero,
in which case the buffer is not used and
the operation returns the minimum required buffer size
(i.e., the length of the prime).
.IP
Diffie-Hellman computations can be performed in user space,
but require a multiple-precision integer (MPI) library.
Moving the implementation into the kernel gives access to
the kernel MPI implementation,
and allows access to secure or acceleration hardware.
.IP
Adding support for DH computation to the
.BR keyctl ()
system call was considered a good fit due to the DH algorithm's use
for deriving shared keys;
it also allows the type of the key to determine
which DH implementation (software or hardware) is appropriate.
.\" commit f1c316a3ab9d24df6022682422fe897492f2c0c8
.IP
If the
.I arg5
argument is
.BR NULL ,
then the DH result itself is returned.
Otherwise (since Linux 4.12), it is a pointer to a structure which specifies
parameters of the KDF operation to be applied:
.IP
.in +4n
.EX
struct keyctl_kdf_params {
    char *hashname;     /* Hash algorithm name */
    char *otherinfo;    /* SP800\-56A OtherInfo */
    __u32 otherinfolen; /* Length of otherinfo data */
    __u32 __spare[8];   /* Reserved */
};
.EE
.in
.IP
The
.I hashname
field is a null-terminated string which specifies a hash name
(available in the kernel's crypto API; the list of the hashes available
is rather tricky to observe; please refer to the
.UR https://www.kernel.org\:/doc\:/html\:/latest\:/crypto\:/architecture.html
"Kernel Crypto API Architecture"
.UE
documentation for the information regarding how hash names are constructed and
your kernel's source and configuration regarding what ciphers
and templates with type
.B CRYPTO_ALG_TYPE_SHASH
are available)
to be applied to DH result in KDF operation.
.IP
The
.I otherinfo
field is an
.I OtherInfo
data as described in SP800-56A section 5.8.1.2 and is algorithm-specific.
This data is concatenated with the result of DH operation and is provided as
an input to the KDF operation.
Its size is provided in the
.I otherinfolen
field and is limited by
.B KEYCTL_KDF_MAX_OI_LEN
constant that defined in
.I security/keys/internal.h
to a value of 64.
.IP
The
.B __spare
field is currently unused.
.\" commit 4f9dabfaf8df971f8a3b6aa324f8f817be38d538
It was ignored until Linux 4.13 (but still should be
user-addressable since it is copied to the kernel),
and should contain zeros since Linux 4.13.
.IP
The KDF implementation complies with SP800-56A as well
as with SP800-108 (the counter KDF).
.IP
.\" keyutils commit 742c9d7b94051d3b21f9f61a73ed6b5f3544cb82
.\" keyutils commit d68a981e5db41d059ac782071c35d1e8f3aaf61c
This operation is exposed by
.I libkeyutils
(from
.I libkeyutils
1.5.10 onwards) via the functions
.BR keyctl_dh_compute (3)
and
.BR keyctl_dh_compute_alloc (3).
.TP
.BR KEYCTL_RESTRICT_KEYRING " (since Linux 4.12)"
.\" commit 6563c91fd645556c7801748f15bc727c77fcd311
.\" commit 7228b66aaf723a623e578aa4db7d083bb39546c9
Apply a key-linking restriction to the keyring with the ID provided in
.I arg2
(cast to
.IR key_serial_t ).
The caller must have
.I setattr
permission on the key.
If
.I arg3
is NULL, any attempt to add a key to the keyring is blocked;
otherwise it contains a pointer to a string with a key type name and
.I arg4
contains a pointer to string that describes the type-specific restriction.
As of Linux 4.12, only the type "asymmetric" has restrictions defined:
.RS
.TP
.B builtin_trusted
Allows only keys that are signed by a key linked to the built-in keyring
(".builtin_trusted_keys").
.TP
.B builtin_and_secondary_trusted
Allows only keys that are signed by a key linked to the secondary keyring
(".secondary_trusted_keys") or, by extension, a key in a built-in keyring,
as the latter is linked to the former.
.TP
.BI key_or_keyring: key
.TQ
.BI key_or_keyring: key :chain
If
.I key
specifies the ID of a key of type "asymmetric",
then only keys that are signed by this key are allowed.
.IP
If
.I key
specifies the ID of a keyring,
then only keys that are signed by a key linked
to this keyring are allowed.
.IP
If ":chain" is specified, keys that are signed by a keys linked to the
destination keyring (that is, the keyring with the ID specified in the
.I arg2
argument) are also allowed.
.RE
.IP
Note that a restriction can be configured only once for the specified keyring;
once a restriction is set, it can't be overridden.
.IP
The argument
.I arg5
is ignored.
.\" FIXME Document KEYCTL_RESTRICT_KEYRING, added in Linux 4.12
.\"     commit 6563c91fd645556c7801748f15bc727c77fcd311
.\"     Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
.\" See Documentation/security/keys.txt
.SH RETURN VALUE
For a successful call, the return value depends on the operation.
.TP
.B KEYCTL_SET_REQKEY_KEYRING
The ID of the previous default keyring
to which implicitly requested keys were linked
(one of
.BR KEY_REQKEY_DEFL_USER_* ).
.TP
.B KEYCTL_ASSUME_AUTHORITY
Either 0, if the ID given was 0,
or the ID of the authorization key matching the specified key,
if a nonzero key ID was provided.
.TP
.B KEYCTL_GET_SECURITY
The size of the LSM security label string
(including the terminating null byte),
irrespective of the provided buffer size.
.TP
.B KEYCTL_GET_PERSISTENT
The ID of the persistent keyring.
.TP
.B KEYCTL_DH_COMPUTE
The number of bytes copied to the buffer, or, if
.I arg4
is 0, the required buffer size.
.TP
All other operations
Zero.
.P
On error, \-1 is returned, and
.I errno
is set to indicate the error.
.SH ERRORS
.TP
.B EACCES
The requested operation wasn't permitted.
.TP
.B EAGAIN
.I operation
was
.B KEYCTL_DH_COMPUTE
and there was an error during crypto module initialization.
.TP
.B EDEADLK
.I operation
was
.B KEYCTL_RESTRICT_KEYRING
and the requested keyring restriction would result in a cycle.
.TP
.B EDQUOT
The key quota for the caller's user would be exceeded by creating a key or
linking it to the keyring.
.TP
.B EEXIST
.I operation
was
.B KEYCTL_RESTRICT_KEYRING
and keyring provided in
.I arg2
argument already has a restriction set.
.TP
.B EFAULT
.I operation
was
.B KEYCTL_DH_COMPUTE
and one of the following has failed:
.RS
.IP \[bu] 3
copying of the
.IR "struct keyctl_dh_params" ,
provided in the
.I arg2
argument, from user space;
.IP \[bu]
copying of the
.IR "struct keyctl_kdf_params" ,
provided in the non-NULL
.I arg5
argument, from user space
(in case kernel supports performing KDF operation on DH operation result);
.IP \[bu]
copying of data pointed by the
.I hashname
field of the
.I "struct keyctl_kdf_params"
from user space;
.IP \[bu]
copying of data pointed by the
.I otherinfo
field of the
.I struct keyctl_kdf_params
from user space if the
.I otherinfolen
field was nonzero;
.IP \[bu]
copying of the result to user space.
.RE
.TP
.B EINVAL
size of the string (including the terminating null byte) specified in
.I arg3
(the key type)
or
.I arg4
(the key description)
exceeded the limit (32 bytes and 4096 bytes respectively).
.TP
.BR EINVAL " (before Linux 4.12)"
.I operation
was
.BR KEYCTL_DH_COMPUTE ,
argument
.I arg5
was non-NULL.
.TP
.B EINVAL
.I operation
was
.B KEYCTL_DH_COMPUTE
And the digest size of the hashing algorithm supplied is zero.
.TP
.B EINVAL
.I operation
was
.B KEYCTL_DH_COMPUTE
and the buffer size provided is not enough to hold the result.
Provide 0 as a buffer size in order to obtain the minimum buffer size.
.TP
.B EINVAL
.I operation
was
.B KEYCTL_DH_COMPUTE
and the hash name provided in the
.I hashname
field of the
.I struct keyctl_kdf_params
pointed by
.I arg5
argument is too big (the limit is implementation-specific and varies between
kernel versions, but it is deemed big enough for all valid algorithm names).
.TP
.B EINVAL
.\" commit 4f9dabfaf8df971f8a3b6aa324f8f817be38d538
.I operation
was
.B KEYCTL_DH_COMPUTE
and the
.I __spare
field of the
.I struct keyctl_kdf_params
provided in the
.I arg5
argument contains nonzero values.
.TP
.B EKEYEXPIRED
An expired key was found or specified.
.TP
.B EKEYREJECTED
A rejected key was found or specified.
.TP
.B EKEYREVOKED
A revoked key was found or specified.
.TP
.B EMSGSIZE
.I operation
was
.B KEYCTL_DH_COMPUTE
and the buffer length exceeds
.B KEYCTL_KDF_MAX_OUTPUT_LEN
(which is 1024 currently)
or the
.I otherinfolen
field of the
.I struct keyctl_kdf_parms
passed in
.I arg5
exceeds
.B KEYCTL_KDF_MAX_OI_LEN
(which is 64 currently).
.TP
.B ENOENT
.I operation
was
.B KEYCTL_DH_COMPUTE
and the hashing algorithm specified in the
.I hashname
field of the
.I struct keyctl_kdf_params
pointed by
.I arg5
argument hasn't been found.
.TP
.B ENOENT
.I operation
was
.B KEYCTL_RESTRICT_KEYRING
and the type provided in
.I arg3
argument doesn't support setting key linking restrictions.
.TP
.B ENOKEY
No matching key was found or an invalid key was specified.
.TP
.B ENOMEM
One of kernel memory allocation routines failed during the execution of the
syscall.
.TP
.B ENOTDIR
A key of keyring type was expected but the ID of a key with
a different type was provided.
.TP
.B EOPNOTSUPP
.I operation
was
.BR KEYCTL_RESTRICT_KEYRING ,
the type provided in
.I arg3
argument was "asymmetric",
and the key specified in the restriction specification provided in
.I arg4
has type other than "asymmetric" or "keyring".
.TP
.B EPERM
.I operation
was
.BR KEYCTL_GET_PERSISTENT ,
.I arg2
specified a UID other than the calling thread's real or effective UID,
and the caller did not have the
.B CAP_SETUID
capability.
.TP
.B EPERM
.I operation
was
.B KEYCTL_SESSION_TO_PARENT
and either:
all of the UIDs (GIDs) of the parent process do not match
the effective UID (GID) of the calling process;
the UID of the parent's existing session keyring or
the UID of the caller's session keyring did not match
the effective UID of the caller;
the parent process is not single-thread;
or the parent process is
.BR init (1)
or a kernel thread.
.TP
.B ETIMEDOUT
.I operation
was
.B KEYCTL_DH_COMPUTE
and the initialization of crypto modules has timed out.
.SH VERSIONS
A wrapper is provided in the
.I libkeyutils
library.
(The accompanying package provides the
.I <keyutils.h>
header file.)
However, rather than using this system call directly,
you probably want to use the various library functions
mentioned in the descriptions of individual operations above.
.SH STANDARDS
Linux.
.SH HISTORY
Linux 2.6.10.
.SH EXAMPLES
The program below provide subset of the functionality of the
.BR request\-key (8)
program provided by the
.I keyutils
package.
For informational purposes,
the program records various information in a log file.
.P
As described in
.BR request_key (2),
the
.BR request\-key (8)
program is invoked with command-line arguments that
describe a key that is to be instantiated.
The example program fetches and logs these arguments.
The program assumes authority to instantiate the requested key,
and then instantiates that key.
.P
The following shell session demonstrates the use of this program.
In the session,
we compile the program and then use it to temporarily replace the standard
.BR request\-key (8)
program.
(Note that temporarily disabling the standard
.BR request\-key (8)
program may not be safe on some systems.)
While our example program is installed,
we use the example program shown in
.BR request_key (2)
to request a key.
.P
.in +4n
.EX
$ \fBcc \-o key_instantiate key_instantiate.c \-lkeyutils\fP
$ \fBsudo mv /sbin/request\-key /sbin/request\-key.backup\fP
$ \fBsudo cp key_instantiate /sbin/request\-key\fP
$ \fB./t_request_key user mykey somepayloaddata\fP
Key ID is 20d035bf
$ \fBsudo mv /sbin/request\-key.backup /sbin/request\-key\fP
.EE
.in
.P
Looking at the log file created by this program,
we can see the command-line arguments supplied to our example program:
.P
.in +4n
.EX
$ \fBcat /tmp/key_instantiate.log\fP
Time: Mon Nov  7 13:06:47 2016
\&
Command line arguments:
  argv[0]:            /sbin/request\-key
  operation:          create
  key_to_instantiate: 20d035bf
  UID:                1000
  GID:                1000
  thread_keyring:     0
  process_keyring:    0
  session_keyring:    256e6a6
\&
Key description:      user;1000;1000;3f010000;mykey
Auth key payload:     somepayloaddata
Destination keyring:  256e6a6
Auth key description: .request_key_auth;1000;1000;0b010000;20d035bf
.EE
.in
.P
The last few lines of the above output show that the example program
was able to fetch:
.IP \[bu] 3
the description of the key to be instantiated,
which included the name of the key
.RI ( mykey );
.IP \[bu]
the payload of the authorization key, which consisted of the data
.RI ( somepayloaddata )
passed to
.BR request_key (2);
.IP \[bu]
the destination keyring that was specified in the call to
.BR request_key (2);
and
.IP \[bu]
the description of the authorization key,
where we can see that the name of the authorization key matches
the ID of the key that is to be instantiated
.RI ( 20d035bf ).
.P
The example program in
.BR request_key (2)
specified the destination keyring as
.BR KEY_SPEC_SESSION_KEYRING .
By examining the contents of
.IR /proc/keys ,
we can see that this was translated to the ID of the destination keyring
.RI ( 0256e6a6 )
shown in the log output above;
we can also see the newly created key with the name
.I mykey
and ID
.IR 20d035bf .
.P
.in +4n
.EX
$ \fBcat /proc/keys | egrep \[aq]mykey|256e6a6\[aq]\fP
0256e6a6 I\-\-Q\-\-\-  194 perm 3f030000  1000  1000 keyring  _ses: 3
20d035bf I\-\-Q\-\-\-    1 perm 3f010000  1000  1000 user     mykey: 16
.EE
.in
.SS Program source
\&
.\" SRC BEGIN (key_instantiate.c)
.EX
/* key_instantiate.c */
\&
#include <errno.h>
#include <keyutils.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <time.h>
\&
#ifndef KEY_SPEC_REQUESTOR_KEYRING
#define KEY_SPEC_REQUESTOR_KEYRING      (\-8)
#endif
\&
int
main(int argc, char *argv[])
{
    int           akp_size;       /* Size of auth_key_payload */
    int           auth_key;
    char          dbuf[256];
    char          auth_key_payload[256];
    char          *operation;
    FILE          *fp;
    gid_t         gid;
    uid_t         uid;
    time_t        t;
    key_serial_t  key_to_instantiate, dest_keyring;
    key_serial_t  thread_keyring, process_keyring, session_keyring;
\&
    if (argc != 8) {
        fprintf(stderr, "Usage: %s op key uid gid thread_keyring "
                        "process_keyring session_keyring\[rs]n", argv[0]);
        exit(EXIT_FAILURE);
    }
\&
    fp = fopen("/tmp/key_instantiate.log", "w");
    if (fp == NULL)
        exit(EXIT_FAILURE);
\&
    setbuf(fp, NULL);
\&
    t = time(NULL);
    fprintf(fp, "Time: %s\[rs]n", ctime(&t));
\&
    /*
     * The kernel passes a fixed set of arguments to the program
     * that it execs; fetch them.
     */
    operation = argv[1];
    key_to_instantiate = atoi(argv[2]);
    uid = atoi(argv[3]);
    gid = atoi(argv[4]);
    thread_keyring = atoi(argv[5]);
    process_keyring = atoi(argv[6]);
    session_keyring = atoi(argv[7]);
\&
    fprintf(fp, "Command line arguments:\[rs]n");
    fprintf(fp, "  argv[0]:            %s\[rs]n", argv[0]);
    fprintf(fp, "  operation:          %s\[rs]n", operation);
    fprintf(fp, "  key_to_instantiate: %jx\[rs]n",
            (uintmax_t) key_to_instantiate);
    fprintf(fp, "  UID:                %jd\[rs]n", (intmax_t) uid);
    fprintf(fp, "  GID:                %jd\[rs]n", (intmax_t) gid);
    fprintf(fp, "  thread_keyring:     %jx\[rs]n",
            (uintmax_t) thread_keyring);
    fprintf(fp, "  process_keyring:    %jx\[rs]n",
            (uintmax_t) process_keyring);
    fprintf(fp, "  session_keyring:    %jx\[rs]n",
            (uintmax_t) session_keyring);
    fprintf(fp, "\[rs]n");
\&
    /*
     * Assume the authority to instantiate the key named in argv[2].
     */
    if (keyctl(KEYCTL_ASSUME_AUTHORITY, key_to_instantiate) == \-1) {
        fprintf(fp, "KEYCTL_ASSUME_AUTHORITY failed: %s\[rs]n",
                strerror(errno));
        exit(EXIT_FAILURE);
    }
\&
    /*
     * Fetch the description of the key that is to be instantiated.
     */
    if (keyctl(KEYCTL_DESCRIBE, key_to_instantiate,
               dbuf, sizeof(dbuf)) == \-1) {
        fprintf(fp, "KEYCTL_DESCRIBE failed: %s\[rs]n", strerror(errno));
        exit(EXIT_FAILURE);
    }
\&
    fprintf(fp, "Key description:      %s\[rs]n", dbuf);
\&
    /*
     * Fetch the payload of the authorization key, which is
     * actually the callout data given to request_key().
     */
    akp_size = keyctl(KEYCTL_READ, KEY_SPEC_REQKEY_AUTH_KEY,
                      auth_key_payload, sizeof(auth_key_payload));
    if (akp_size == \-1) {
        fprintf(fp, "KEYCTL_READ failed: %s\[rs]n", strerror(errno));
        exit(EXIT_FAILURE);
    }
\&
    auth_key_payload[akp_size] = \[aq]\[rs]0\[aq];
    fprintf(fp, "Auth key payload:     %s\[rs]n", auth_key_payload);
\&
    /*
     * For interest, get the ID of the authorization key and
     * display it.
     */
    auth_key = keyctl(KEYCTL_GET_KEYRING_ID,
                      KEY_SPEC_REQKEY_AUTH_KEY);
    if (auth_key == \-1) {
        fprintf(fp, "KEYCTL_GET_KEYRING_ID failed: %s\[rs]n",
                strerror(errno));
        exit(EXIT_FAILURE);
    }
\&
    fprintf(fp, "Auth key ID:          %jx\[rs]n", (uintmax_t) auth_key);
\&
    /*
     * Fetch key ID for the request_key(2) destination keyring.
     */
    dest_keyring = keyctl(KEYCTL_GET_KEYRING_ID,
                          KEY_SPEC_REQUESTOR_KEYRING);
    if (dest_keyring == \-1) {
        fprintf(fp, "KEYCTL_GET_KEYRING_ID failed: %s\[rs]n",
                strerror(errno));
        exit(EXIT_FAILURE);
    }
\&
    fprintf(fp, "Destination keyring:  %jx\[rs]n", (uintmax_t) dest_keyring);
\&
    /*
     * Fetch the description of the authorization key. This
     * allows us to see the key type, UID, GID, permissions,
     * and description (name) of the key. Among other things,
     * we will see that the name of the key is a hexadecimal
     * string representing the ID of the key to be instantiated.
     */
    if (keyctl(KEYCTL_DESCRIBE, KEY_SPEC_REQKEY_AUTH_KEY,
               dbuf, sizeof(dbuf)) == \-1)
    {
        fprintf(fp, "KEYCTL_DESCRIBE failed: %s\[rs]n", strerror(errno));
        exit(EXIT_FAILURE);
    }
\&
    fprintf(fp, "Auth key description: %s\[rs]n", dbuf);
\&
    /*
     * Instantiate the key using the callout data that was supplied
     * in the payload of the authorization key.
     */
    if (keyctl(KEYCTL_INSTANTIATE, key_to_instantiate,
               auth_key_payload, akp_size + 1, dest_keyring) == \-1)
    {
        fprintf(fp, "KEYCTL_INSTANTIATE failed: %s\[rs]n",
                strerror(errno));
        exit(EXIT_FAILURE);
    }
\&
    exit(EXIT_SUCCESS);
}
.EE
.\" SRC END
.SH SEE ALSO
.ad l
.nh
.BR keyctl (1),
.BR add_key (2),
.BR request_key (2),
.\"     .BR find_key_by_type_and_name (3)
.\"     There is a man page, but this function seems not to exist
.BR keyctl (3),
.BR keyctl_assume_authority (3),
.BR keyctl_dh_compute (3),
.BR keyctl_dh_compute_alloc (3),
.BR keyctl_get_persistent (3),
.BR keyctl_get_security (3),
.BR keyctl_get_security_alloc (3),
.BR keyctl_instantiate (3),
.BR keyctl_instantiate_iov (3),
.BR keyctl_invalidate (3),
.BR keyctl_negate (3),
.BR keyctl_reject (3),
.BR keyctl_session_to_parent (3),
.BR keyctl_set_reqkey_keyring (3),
.BR keyctl_set_timeout (3),
.BR recursive_key_scan (3),
.BR recursive_session_key_scan (3),
.BR capabilities (7),
.BR credentials (7),
.BR keyrings (7),
.BR keyutils (7),
.BR persistent\-keyring (7),
.BR process\-keyring (7),
.BR session\-keyring (7),
.BR thread\-keyring (7),
.BR user\-keyring (7),
.BR user_namespaces (7),
.BR user\-session\-keyring (7),
.BR request\-key (8)
.P
The kernel source files under
.I Documentation/security/keys/
(or, before Linux 4.13, in the file
.IR Documentation/security/keys.txt ).
