.\" Copyright (C) 1998 Andries Brouwer (aeb@cwi.nl)
.\" and Copyright (C) 2002, 2006, 2008, 2012, 2013, 2015 Michael Kerrisk <mtk.manpages@gmail.com>
.\" and Copyright Guillem Jover <guillem@hadrons.org>
.\" and Copyright (C) 2010 Andi Kleen <andi@firstfloor.org>
.\" and Copyright (C) 2012 Cyrill Gorcunov <gorcunov@openvz.org>
.\" and Copyright (C) 2014 Dave Hansen / Intel
.\" and Copyright (c) 2016 Eugene Syromyatnikov <evgsyr@gmail.com>
.\" and Copyright (c) 2018 Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
.\" and Copyright (c) 2020 Dave Martin <Dave.Martin@arm.com>
.\"
.\" SPDX-License-Identifier: Linux-man-pages-copyleft
.\"
.\" Modified 2006-08-30 Guillem Jover <guillem@hadrons.org>
.\"	Updated Linux versions where the options where introduced.
.\"	Added PR_SET_TIMING, PR_GET_TIMING
.\"	PR_SET_UNALIGN, PR_GET_UNALIGN,
.\" 2008-06-13 Erik Bosman, <ejbosman@cs.vu.nl>
.\"     Document PR_GET_TSC and PR_SET_TSC.
.\" 2012-04-25 Michael Kerrisk, Document PR_TASK_PERF_EVENTS_DISABLE and
.\"				PR_TASK_PERF_EVENTS_ENABLE
.\" 2012-10-25 Michael Kerrisk, Document PR_SET_TIMERSLACK and
.\"                             PR_GET_TIMERSLACK
.\"
.TH prctl 2 (date) "Linux man-pages (unreleased)"
.SH NAME
prctl \- operations on a process or thread
.SH LIBRARY
Standard C library
.RI ( libc ", " \-lc )
.SH SYNOPSIS
.nf
.B #include <sys/prctl.h>
.P
.BI "int prctl(int " op ", ...);"
.fi
.SH DESCRIPTION
.BR prctl ()
manipulates various aspects of the behavior
of the calling thread or process.
.P
Note that careless use of some
.BR prctl ()
operations can confuse the user-space run-time environment,
so these operations should be used with care.
.P
.BR prctl ()
is called with a first argument describing what to do
(with values defined in \fI<linux/prctl.h>\fP), and further
arguments with a significance depending on the first one.
The first argument can be:
.\"
.TP
.B PR_CAP_AMBIENT
.TQ
.B PR_CAPBSET_READ
.TQ
.B PR_CAPBSET_DROP
.TQ
.B PR_SET_CHILD_SUBREAPER
.TQ
.B PR_GET_CHILD_SUBREAPER
.TQ
.B PR_SET_DUMPABLE
.TQ
.B PR_GET_DUMPABLE
.TQ
.B PR_SET_ENDIAN
.TQ
.B PR_GET_ENDIAN
.TQ
.B PR_SET_FP_MODE
.TQ
.B PR_GET_FP_MODE
.TQ
.B PR_SET_FPEMU
.TQ
.B PR_GET_FPEMU
.TQ
.B PR_SET_FPEXC
.TQ
.B PR_GET_FPEXC
.TQ
.B PR_SET_IO_FLUSHER
.TQ
.B PR_GET_IO_FLUSHER
.TQ
.B PR_SET_KEEPCAPS
.TQ
.B PR_GET_KEEPCAPS
.TQ
.B PR_MCE_KILL
.TQ
.B PR_MCE_KILL_GET
.TQ
.B PR_SET_MM
.TQ
.B PR_SET_VMA
.TQ
.B PR_MPX_ENABLE_MANAGEMENT
.TQ
.B PR_MPX_DISABLE_MANAGEMENT
.TQ
.B PR_SET_NAME
.TQ
.B PR_GET_NAME
.TQ
.B PR_SET_NO_NEW_PRIVS
.TQ
.B PR_GET_NO_NEW_PRIVS
.TQ
.B PR_PAC_RESET_KEYS
.TQ
.B PR_SET_PDEATHSIG
.TQ
.B PR_GET_PDEATHSIG
.TQ
.B PR_SET_PTRACER
.TQ
.B PR_SET_SECCOMP
.TQ
.B PR_GET_SECCOMP
.TQ
.B PR_SET_SECUREBITS
.TQ
.B PR_GET_SECUREBITS
.TQ
.B PR_GET_SPECULATION_CTRL
.TQ
.B PR_SET_SPECULATION_CTRL
.TQ
.B PR_SVE_SET_VL
.TQ
.B PR_SVE_GET_VL
.TQ
.B PR_SET_SYSCALL_USER_DISPATCH
.\" prctl PR_SET_TAGGED_ADDR_CTRL
.\" commit 63f0c60379650d82250f22e4cf4137ef3dc4f43d
.TP
.BR PR_SET_TAGGED_ADDR_CTRL " (since Linux 5.4, only on arm64)"
Controls support for passing tagged user-space addresses to the kernel
(i.e., addresses where bits 56\[em]63 are not all zero).
.IP
The level of support is selected by
.IR "arg2" ,
which can be one of the following:
.RS
.TP
.B 0
Addresses that are passed
for the purpose of being dereferenced by the kernel
must be untagged.
.TP
.B PR_TAGGED_ADDR_ENABLE
Addresses that are passed
for the purpose of being dereferenced by the kernel
may be tagged, with the exceptions summarized below.
.RE
.IP
The remaining arguments
.IR arg3 ", " arg4 ", and " arg5
must all be zero.
.\" Enforcement added in
.\" commit 3e91ec89f527b9870fe42dcbdb74fd389d123a95
.IP
On success, the mode specified in
.I arg2
is set for the calling thread and the return value is 0.
If the arguments are invalid,
the mode specified in
.I arg2
is unrecognized,
or if this feature is unsupported by the kernel
or disabled via
.IR /proc/sys/abi/tagged_addr_disabled ,
the call fails with the error
.BR EINVAL .
.IP
In particular, if
.BR prctl ( PR_SET_TAGGED_ADDR_CTRL ,
0, 0, 0, 0)
fails with
.BR EINVAL ,
then all addresses passed to the kernel must be untagged.
.IP
Irrespective of which mode is set,
addresses passed to certain interfaces
must always be untagged:
.RS
.IP \[bu] 3
.BR brk (2),
.BR mmap (2),
.BR shmat (2),
.BR shmdt (2),
and the
.I new_address
argument of
.BR mremap (2).
.IP
(Prior to Linux 5.6 these accepted tagged addresses,
but the behaviour may not be what you expect.
Don't rely on it.)
.IP \[bu]
\[oq]polymorphic\[cq] interfaces
that accept pointers to arbitrary types cast to a
.I void *
or other generic type, specifically
.BR prctl (),
.BR ioctl (2),
and in general
.BR setsockopt (2)
(only certain specific
.BR setsockopt (2)
options allow tagged addresses).
.RE
.IP
This list of exclusions may shrink
when moving from one kernel version to a later kernel version.
While the kernel may make some guarantees
for backwards compatibility reasons,
for the purposes of new software
the effect of passing tagged addresses to these interfaces
is unspecified.
.IP
The mode set by this call is inherited across
.BR fork (2)
and
.BR clone (2).
The mode is reset by
.BR execve (2)
to 0
(i.e., tagged addresses not permitted in the user/kernel ABI).
.IP
For more information, see the kernel source file
.IR Documentation/arm64/tagged\-address\-abi.rst .
.IP
.B Warning:
This call is primarily intended for use by the run-time environment.
A successful
.B PR_SET_TAGGED_ADDR_CTRL
call elsewhere may crash the calling process.
The conditions for using it safely are complex and system-dependent.
Don't use it unless you know what you are doing.
.\" prctl PR_GET_TAGGED_ADDR_CTRL
.\" commit 63f0c60379650d82250f22e4cf4137ef3dc4f43d
.TP
.BR PR_GET_TAGGED_ADDR_CTRL " (since Linux 5.4, only on arm64)"
Returns the current tagged address mode
for the calling thread.
.IP
Arguments
.IR arg2 ", " arg3 ", " arg4 ", and " arg5
must all be zero.
.IP
If the arguments are invalid
or this feature is disabled or unsupported by the kernel,
the call fails with
.BR EINVAL .
In particular, if
.BR prctl ( PR_GET_TAGGED_ADDR_CTRL ,
0, 0, 0, 0)
fails with
.BR EINVAL ,
then this feature is definitely either unsupported,
or disabled via
.IR /proc/sys/abi/tagged_addr_disabled .
In this case,
all addresses passed to the kernel must be untagged.
.IP
Otherwise, the call returns a nonnegative value
describing the current tagged address mode,
encoded in the same way as the
.I arg2
argument of
.BR PR_SET_TAGGED_ADDR_CTRL .
.IP
For more information, see the kernel source file
.IR Documentation/arm64/tagged\-address\-abi.rst .
.\"
.\" prctl PR_TASK_PERF_EVENTS_DISABLE
.TP
.BR PR_TASK_PERF_EVENTS_DISABLE " (since Linux 2.6.31)"
Disable all performance counters attached to the calling process,
regardless of whether the counters were created by
this process or another process.
Performance counters created by the calling process for other
processes are unaffected.
For more information on performance counters, see the Linux kernel source file
.IR tools/perf/design.txt .
.IP
Originally called
.BR PR_TASK_PERF_COUNTERS_DISABLE ;
.\" commit 1d1c7ddbfab358445a542715551301b7fc363e28
renamed (retaining the same numerical value)
in Linux 2.6.32.
.\"
.\" prctl PR_TASK_PERF_EVENTS_ENABLE
.TP
.BR PR_TASK_PERF_EVENTS_ENABLE " (since Linux 2.6.31)"
The converse of
.BR PR_TASK_PERF_EVENTS_DISABLE ;
enable performance counters attached to the calling process.
.IP
Originally called
.BR PR_TASK_PERF_COUNTERS_ENABLE ;
.\" commit 1d1c7ddbfab358445a542715551301b7fc363e28
renamed
.\" commit cdd6c482c9ff9c55475ee7392ec8f672eddb7be6
in Linux 2.6.32.
.\"
.\" prctl PR_SET_THP_DISABLE
.TP
.BR PR_SET_THP_DISABLE " (since Linux 3.15)"
.\" commit a0715cc22601e8830ace98366c0c2bd8da52af52
Set the state of the "THP disable" flag for the calling thread.
If
.I arg2
has a nonzero value, the flag is set, otherwise it is cleared.
Setting this flag provides a method
for disabling transparent huge pages
for jobs where the code cannot be modified, and using a malloc hook with
.BR madvise (2)
is not an option (i.e., statically allocated data).
The setting of the "THP disable" flag is inherited by a child created via
.BR fork (2)
and is preserved across
.BR execve (2).
.\" prctl PR_GET_THP_DISABLE
.TP
.BR PR_GET_THP_DISABLE " (since Linux 3.15)"
Return (as the function result) the current setting of the "THP disable"
flag for the calling thread:
either 1, if the flag is set, or 0, if it is not.
.\" prctl PR_GET_TID_ADDRESS
.TP
.BR PR_GET_TID_ADDRESS " (since Linux 3.5)"
.\" commit 300f786b2683f8bb1ec0afb6e1851183a479c86d
Return the
.I clear_child_tid
address set by
.BR set_tid_address (2)
and the
.BR clone (2)
.B CLONE_CHILD_CLEARTID
flag, in the location pointed to by
.IR "(int\~**)\~arg2" .
This feature is available only if the kernel is built with the
.B CONFIG_CHECKPOINT_RESTORE
option enabled.
Note that since the
.BR prctl ()
system call does not have a compat implementation for
the AMD64 x32 and MIPS n32 ABIs,
and the kernel writes out a pointer using the kernel's pointer size,
this operation expects a user-space buffer of 8 (not 4) bytes on these ABIs.
.\" prctl PR_SET_TIMERSLACK
.TP
.BR PR_SET_TIMERSLACK " (since Linux 2.6.28)"
.\" See https://lwn.net/Articles/369549/
.\" commit 6976675d94042fbd446231d1bd8b7de71a980ada
Each thread has two associated timer slack values:
a "default" value, and a "current" value.
This operation sets the "current" timer slack value for the calling thread.
.I arg2
is an unsigned long value, then maximum "current" value is ULONG_MAX and
the minimum "current" value is 1.
If the nanosecond value supplied in
.I arg2
is greater than zero, then the "current" value is set to this value.
If
.I arg2
is equal to zero,
the "current" timer slack is reset to the
thread's "default" timer slack value.
.IP
The "current" timer slack is used by the kernel to group timer expirations
for the calling thread that are close to one another;
as a consequence, timer expirations for the thread may be
up to the specified number of nanoseconds late (but will never expire early).
Grouping timer expirations can help reduce system power consumption
by minimizing CPU wake-ups.
.IP
The timer expirations affected by timer slack are those set by
.BR select (2),
.BR pselect (2),
.BR poll (2),
.BR ppoll (2),
.BR epoll_wait (2),
.BR epoll_pwait (2),
.BR clock_nanosleep (2),
.BR nanosleep (2),
and
.BR futex (2)
(and thus the library functions implemented via futexes, including
.\" List obtained by grepping for futex usage in glibc source
.BR pthread_cond_timedwait (3),
.BR pthread_mutex_timedlock (3),
.BR pthread_rwlock_timedrdlock (3),
.BR pthread_rwlock_timedwrlock (3),
and
.BR sem_timedwait (3)).
.IP
Timer slack is not applied to threads that are scheduled under
a real-time scheduling policy (see
.BR sched_setscheduler (2)).
.IP
When a new thread is created,
the two timer slack values are made the same as the "current" value
of the creating thread.
Thereafter, a thread can adjust its "current" timer slack value via
.BR PR_SET_TIMERSLACK .
The "default" value can't be changed.
The timer slack values of
.I init
(PID 1), the ancestor of all processes,
are 50,000 nanoseconds (50 microseconds).
The timer slack value is inherited by a child created via
.BR fork (2),
and is preserved across
.BR execve (2).
.IP
Since Linux 4.6, the "current" timer slack value of any process
can be examined and changed via the file
.IR /proc/ pid /timerslack_ns .
See
.BR proc (5).
.\" prctl PR_GET_TIMERSLACK
.TP
.BR PR_GET_TIMERSLACK " (since Linux 2.6.28)"
Return (as the function result)
the "current" timer slack value of the calling thread.
.\" prctl PR_SET_TIMING
.TP
.BR PR_SET_TIMING " (since Linux 2.6.0)"
.\" Precisely: Linux 2.6.0-test4
Set whether to use (normal, traditional) statistical process timing or
accurate timestamp-based process timing, by passing
.B PR_TIMING_STATISTICAL
.\" 0
or
.B PR_TIMING_TIMESTAMP
.\" 1
to \fIarg2\fP.
.B PR_TIMING_TIMESTAMP
is not currently implemented
(attempting to set this mode will yield the error
.BR EINVAL ).
.\" PR_TIMING_TIMESTAMP doesn't do anything in Linux 2.6.26-rc8,
.\" and looking at the patch history, it appears
.\" that it never did anything.
.\" prctl PR_GET_TIMING
.TP
.BR PR_GET_TIMING " (since Linux 2.6.0)"
.\" Precisely: Linux 2.6.0-test4
Return (as the function result) which process timing method is currently
in use.
.\" prctl PR_SET_TSC
.TP
.BR PR_SET_TSC " (since Linux 2.6.26, x86 only)"
Set the state of the flag determining whether the timestamp counter
can be read by the process.
Pass
.B PR_TSC_ENABLE
to
.I arg2
to allow it to be read, or
.B PR_TSC_SIGSEGV
to generate a
.B SIGSEGV
when the process tries to read the timestamp counter.
.\" prctl PR_GET_TSC
.TP
.BR PR_GET_TSC " (since Linux 2.6.26, x86 only)"
Return the state of the flag determining whether the timestamp counter
can be read,
in the location pointed to by
.IR "(int\~*) arg2" .
.\" prctl PR_SET_UNALIGN
.TP
.B PR_SET_UNALIGN
(Only on: ia64, since Linux 2.3.48; parisc, since Linux 2.6.15;
PowerPC, since Linux 2.6.18; Alpha, since Linux 2.6.22;
.\" sh: 94ea5e449ae834af058ef005d16a8ad44fcf13d6
.\" tile: 2f9ac29eec71a696cb0dcc5fb82c0f8d4dac28c9
sh, since Linux 2.6.34; tile, since Linux 3.12)
Set unaligned access control bits to \fIarg2\fP.
Pass
\fBPR_UNALIGN_NOPRINT\fP to silently fix up unaligned user accesses,
or \fBPR_UNALIGN_SIGBUS\fP to generate
.B SIGBUS
on unaligned user access.
Alpha also supports an additional flag with the value
of 4 and no corresponding named constant,
which instructs kernel to not fix up
unaligned accesses (it is analogous to providing the
.B UAC_NOFIX
flag in
.B SSI_NVPAIRS
operation of the
.BR setsysinfo ()
system call on Tru64).
.\" prctl PR_GET_UNALIGN
.TP
.B PR_GET_UNALIGN
(See
.B PR_SET_UNALIGN
for information on versions and architectures.)
Return unaligned access control bits, in the location pointed to by
.IR "(unsigned int\~*) arg2" .
.\" prctl PR_GET_AUXV
.TP
.BR PR_GET_AUXV " (since Linux 6.4)"
Get the auxiliary vector (auxv) into the buffer pointed to by
.IR "(void\~*) arg2" ,
whose length is given by \fIarg3\fP.
If the buffer is not long enough for the full auxiliary vector,
the copy will be truncated.
Return (as the function result)
the full length of the auxiliary vector.
\fIarg4\fP and \fIarg5\fP must be 0.
.TP
.BR PR_SET_MDWE " (since Linux 6.3)"
.\" commit b507808ebce23561d4ff8c2aa1fb949fe402bc61
Set the calling process' Memory-Deny-Write-Execute protection mask.
Once protection bits are set,
they can not be changed.
.I arg2
must be a bit mask of:
.RS
.TP
.B PR_MDWE_REFUSE_EXEC_GAIN
New memory mapping protections can't be writable and executable.
Non-executable mappings can't become executable.
.TP
.B PR_MDWE_NO_INHERIT " (since Linux 6.6)"
.\" commit 2a87e5520554034e8c423479740f95bea4a086a0
Do not propagate MDWE protection to child processes on
.BR fork (2).
Setting this bit requires setting
.B PR_MDWE_REFUSE_EXEC_GAIN
too.
.RE
.TP
.BR PR_GET_MDWE " (since Linux 6.3)"
.\" commit b507808ebce23561d4ff8c2aa1fb949fe402bc61
Return (as the function result) the Memory-Deny-Write-Execute protection mask
of the calling process.
(See
.B PR_SET_MDWE
for information on the protection mask bits.)
.SH RETURN VALUE
On success,
.BR PR_GET_TAGGED_ADDR_CTRL ,
.BR PR_GET_THP_DISABLE ,
.BR PR_GET_TIMING ,
.BR PR_GET_TIMERSLACK ,
.BR PR_GET_AUXV ,
return the nonnegative values described above.
All other
.I op
values return 0 on success.
On error, \-1 is returned, and
.I errno
is set to indicate the error.
.SH ERRORS
.TP
.B EFAULT
.I arg2
is an invalid address.
.TP
.B EINVAL
The value of
.I op
is not recognized,
or not supported on this system.
.TP
.B EINVAL
An unused argument is nonzero.
.TP
.B EINVAL
.I arg2
is not a valid value for this
.IR op .
.TP
.B EINVAL
.I op
is
.B PR_SET_TIMING
and
.I arg2
is not
.BR PR_TIMING_STATISTICAL .
.TP
.B EINVAL
.I op
is
.B PR_SET_TAGGED_ADDR_CTRL
and the arguments are invalid or unsupported.
See the description of
.B PR_SET_TAGGED_ADDR_CTRL
above for details.
.TP
.B EINVAL
.I op
is
.B PR_GET_TAGGED_ADDR_CTRL
and the arguments are invalid or unsupported.
See the description of
.B PR_GET_TAGGED_ADDR_CTRL
above for details.
.SH VERSIONS
IRIX has a
.BR prctl ()
system call (also introduced in Linux 2.1.44
as irix_prctl on the MIPS architecture),
with prototype
.P
.in +4n
.EX
.BI "ptrdiff_t prctl(int " op ", int " arg2 ", int " arg3 );
.EE
.in
.P
and operations to get the maximum number of processes per user,
get the maximum number of processors the calling process can use,
find out whether a specified process is currently blocked,
get or set the maximum stack size, and so on.
.SH STANDARDS
Linux.
.SH HISTORY
Linux 2.1.57,
glibc 2.0.6
.SH SEE ALSO
.BR signal (2),
.BR PR_CAP_AMBIENT (2const),
.BR PR_CAPBSET_READ (2const),
.BR PR_CAPBSET_DROP (2const),
.BR PR_SET_CHILD_SUBREAPER (2const),
.BR PR_GET_CHILD_SUBREAPER (2const),
.BR PR_SET_DUMPABLE (2const),
.BR PR_GET_DUMPABLE (2const),
.BR PR_SET_ENDIAN (2const),
.BR PR_GET_ENDIAN (2const),
.BR PR_SET_FP_MODE (2const),
.BR PR_GET_FP_MODE (2const),
.BR PR_SET_FPEMU (2const),
.BR PR_GET_FPEMU (2const),
.BR PR_SET_FPEXC (2const),
.BR PR_GET_FPEXC (2const),
.BR PR_SET_IO_FLUSHER (2const),
.BR PR_GET_IO_FLUSHER (2const),
.BR PR_SET_KEEPCAPS (2const),
.BR PR_GET_KEEPCAPS (2const),
.BR PR_MCE_KILL (2const),
.BR PR_MCE_KILL_GET (2const),
.BR PR_SET_MM (2const),
.BR PR_SET_VMA (2const),
.BR PR_MPX_ENABLE_MANAGEMENT (2const),
.BR PR_MPX_DISABLE_MANAGEMENT (2const),
.BR PR_SET_NAME (2const),
.BR PR_GET_NAME (2const),
.BR PR_SET_NO_NEW_PRIVS (2const),
.BR PR_GET_NO_NEW_PRIVS (2const),
.BR PR_PAC_RESET_KEYS (2const),
.BR PR_SET_PDEATHSIG (2const),
.BR PR_GET_PDEATHSIG (2const),
.BR PR_SET_PTRACER (2const),
.BR PR_SET_SECCOMP (2const),
.BR PR_GET_SECCOMP (2const),
.BR PR_SET_SECUREBITS (2const),
.BR PR_GET_SECUREBITS (2const),
.BR PR_SET_SPECULATION_CTRL (2const),
.BR PR_GET_SPECULATION_CTRL (2const),
.BR PR_SVE_SET_VL (2const),
.BR PR_SVE_GET_VL (2const),
.BR PR_SET_SYSCALL_USER_DISPATCH (2const),
.BR core (5)
